<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: API: Material management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">904ecaf4554303f255d3b826b24ef9cc87f8d90a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('develmaterials.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">API: Material management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md73">Content of the Radium Material Library</a></li>
<li class="level1"><a href="#simple-mtl-usage">Simple usage of materials</a></li>
<li class="level1"><a href="#extend-mtl-lib">Extending the Radium Material Library</a><ul><li class="level2"><a href="#cpp-mtl-lib">C++ interface</a></li>
<li class="level2"><a href="#glsl-mtl-lib">GLSL interface</a></li>
<li class="level2"><a href="#autotoc_md74">Appearance computation needs</a><ul><li class="level3"><a href="#vrtx-attr-interface">Vertex attrib interface</a></li>
<li class="level3"><a href="#microgeometry-interface">Microgeometry interface</a></li>
<li class="level3"><a href="#bsdf-interface">BSDF interface</a></li>
<li class="level3"><a href="#emissivity-interface">Emissivity interface</a></li>
</ul>
</li>
<li class="level2"><a href="#registration-mtl-lib">Material registration into the Engine</a></li>
<li class="level2"><a href="#non-bsdf-rendering">Rendering without using Materials</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>A <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> is a way to control the appearance of an object when rendering. A <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> defines the <em>Bidirectional Scattering Distribution function (BSDF)</em> to be applied on an object.</p>
<p>A material is associated to the render geometry of an object (a <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a>) through a <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>.</p>
<p>A <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> describes how to use a <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> to render an object in OpenGL and consists in a set of named <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> that encompass the OpenGL representation of a Material (glsl code and associated data) with, at least, vertex and fragment shaders. The name of each <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> corresponds to the way a <a class="el" href="classRa_1_1Engine_1_1Renderer.html">Ra::Engine::Renderer</a> manages its rendering loop.</p>
<p>A <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> is associated with a <a class="el" href="classRa_1_1Engine_1_1ShaderProgram.html">Ra::Engine::ShaderProgram</a> bound by the <a class="el" href="classRa_1_1Engine_1_1Renderer.html">Ra::Engine::Renderer</a> when rendering an object.</p>
<p>The Radium Engine exposes some predefined materials, the <em>Radium Material Library</em>, with render techniques corresponding to the <a class="el" href="classRa_1_1Engine_1_1ForwardRenderer.html">Ra::Engine::ForwardRenderer</a> default renderer.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Content of the Radium Material Library</h1>
<p>The Radium Material Library defines two default material :</p><ul>
<li>BlinnPhong, <a class="el" href="classRa_1_1Engine_1_1BlinnPhongMaterial.html">Ra::Engine::BlinnPhongMaterial</a>, corresponding to the Blinn-Phong BSDF.</li>
<li>Plain, <a class="el" href="classRa_1_1Engine_1_1PlainMaterial.html">Ra::Engine::PlainMaterial</a>, corresponding to a diffuse, lambertian BSDF.</li>
</ul>
<p>The <em>Radium Material Library</em> can be used as this by any Radium Application or can be extended by an application or a Radium Plugin by implementing the corresponding interfaces as described in the <a href="#extend-mtl-lib">Extending the _Radium Material Library</a>.</p>
<p>For each material of the library, a default <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>, corresponding to the standard usage of the material by the Ra::engine::ForwardRenderer and an optional <a class="el" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#af97fe019a3c335e8ee248209b0b1ee71">Ra::Engine::EngineMaterialConverters::ConverterFunction</a>, used when loading files to convert file representation of a Material to Radium representation of this material, are made available through the dedicated factories <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html">Ra::Engine::EngineRenderTechniques</a> and <a class="el" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html">Ra::Engine::EngineMaterialConverters</a>.</p>
<p>See the <a href="#registration-mtl-lib">Material registration into the Engine</a> section of this documentation to learn more about these factories.</p>
<h1><a class="anchor" id="simple-mtl-usage"></a>
Simple usage of materials</h1>
<p>A simple usage of material is demonstrated in the <a href="https://github.com/STORM-IRIT/Radium-Apps">HelloRadium Application</a>.</p>
<p>When building scene to render, a <a class="el" href="classRa_1_1Engine_1_1Component.html" title="A component is an element that can be updated by a system. It is also linked to some other components...">Ra::Engine::Component</a> must be added to a system as described into the <em>Radium Engine programmer manual</em>. A component holds one or several <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a> that will be drawn when rendering.</p>
<p>To define a <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a> and add it to the component, the geometry of a 3D object (a <a class="el" href="classRa_1_1Engine_1_1Mesh.html" title="Mesh, own a Core::Geometry::TriangleMesh. ">Ra::Engine::Mesh</a>) must be associated with a <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> that links to the required <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a>.</p>
<p>To do that, the following steps must be done :</p><ol type="1">
<li>Create the <a class="el" href="classRa_1_1Engine_1_1Mesh.html" title="Mesh, own a Core::Geometry::TriangleMesh. ">Ra::Engine::Mesh</a> (see the <a class="el" href="develmeshes.html">documentation about Meshes</a>) <div class="fragment"></div><!-- fragment --></li>
<li>Create the <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> <div class="fragment"></div><!-- fragment --></li>
<li>Create the <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>, here using the <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html">Ra::Engine::EngineRenderTechniques</a> factory, and associate it to the material <div class="fragment"></div><!-- fragment --></li>
<li>Create the <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a> and add it to the <a class="el" href="classRa_1_1Engine_1_1Component.html" title="A component is an element that can be updated by a system. It is also linked to some other components...">Ra::Engine::Component</a> <div class="fragment"></div><!-- fragment --> Note that this way of using the <em>Radium Material Library</em> is very related to the default Radium rendering capabilities exposed by the <a class="el" href="forwardrendererconcept.html">Radium forward renderer</a>. See the <a href="./rendertechnique">Render technique management</a> documentation to learn how to create your own <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>, potentially without associated material.</li>
</ol>
<p>If one wants to render objects without BSDF computation but with a specific color computation for the fragment, follow the guidelines from <a href="#non-bsdf-rendering">the dedicated section</a> of this documentation.</p>
<h1><a class="anchor" id="extend-mtl-lib"></a>
Extending the Radium Material Library</h1>
<p>The <em>Radium Material Library</em> could be extended to handle several <em>Bidirectional Scattering Distribution function</em>.</p>
<p>In order to make these extensions available to each Radium developer, the <em>Radium Material Library</em> defines several interfaces and factories for material management.</p>
<p>A material is defined by two programming interfaces. The <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> that defines the <a href="#cpp-mtl-lib">C++ interface</a> made available for applications and plugins and a <a href="#glsl-mtl-lib">GLSL interface</a> that allows shader reuse and composition for OpenGL rendering.</p>
<p>The C++ interface is implemented in a <code>NameOfTheMaterial.hpp/.cpp</code> source file.</p>
<p>The GLSL interface is composed of several parts :</p><ol type="1">
<li>The implementation of a <a href="#bsdf-interface">BSDF interface</a> and a <a href="#microgeometry-interface">micro-geometry interface</a> in a <code>NameOfBSDF.glsl</code> file that will be included in every fragment shaders that need the implementation of the bsdf.</li>
<li>The implementation of one or several vertex shaders that will compute the data used by the <a href="#vrtx-attr-interface">vertex attrib interface</a>. These shaders are renderer-specific and the programmer must at least give one for the Radium default renderer.</li>
<li>The implementation of one or several fragment shaders that, by using the <a href="#vrtx-attr-interface">vertex attrib interface</a>, will compute the final color of a fragment using the <a href="#bsdf-interface">BSDF interface</a> and the <a href="#microgeometry-interface">micro-geometry interface</a>. These shaders are renderer-specific and the programmer must at least give one for the Radium default renderer.</li>
</ol>
<h2><a class="anchor" id="cpp-mtl-lib"></a>
C++ interface</h2>
<p>The <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> interface defines the internal abstract representation of a Material. This interface defines all the methods required to parametrized the OpenGL pipeline for rendering and will be used mainly by the <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> and the <a class="el" href="classRa_1_1Engine_1_1Renderer.html">Ra::Engine::Renderer</a> classes.</p>
<p>When implementing this interface, and in order to make the material available to all applications or plugins, two static methods to register and unregister the material into the <em>Radium Material Library</em> must also be developed. These method will populate the <em>Radium Material Library</em> factories with specific helper functions to use the material in the default Radium forward renderer. Mainly, the <code>registerMaterial()</code> method will record an helper function to build a material-related <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> dedicated to the Radium forward renderer. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMaterial : <span class="keyword">public</span> <a class="code" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// implementation of the abstract interface</span></div><div class="line">    ...</div><div class="line">private:</div><div class="line">    <span class="comment">// data member for MyMaterial</span></div><div class="line">    ...</div><div class="line">public:</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> registerMaterial();</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> unregisterMaterial();</div><div class="line">    <span class="comment">// MyMaterial specific public interface</span></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> See the <a href="./rendertechnique">Render technique management</a> for documentation on how to build such an helper function.</p>
<h2><a class="anchor" id="glsl-mtl-lib"></a>
GLSL interface</h2>
<p>Being able to compose shaders in a specific renderer while taking profit of Radium Material Library (either included in the base engine or defined in plugins) require a clean definition of appearance computation process and the definition of a glsl interface.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Appearance computation needs</h2>
<p>In order to compute the appearance of an object, and according to the OpenGL/GLSL approach of rendering, several aspects might be taken into account and might be integrated into the interface definition to make a material renderer-agnostic.</p>
<p>The user or the implementer could rely on default implementation, provided by the <em>Radium Material Library</em> of most of these functionalities and concentrate its effort in developing the required functionalities for its material/renderer.</p>
<ol type="1">
<li>Accessing or computing <a href="#vrtx-attr-interface">appearance attributes that depends on geometric data</a>, such as<ul>
<li>vertex attribs (normal, position, color, ...)</li>
</ul>
</li>
<li>Accessing or computing <a href="#microgeometry-interface">microgeometric attributes</a> that depends on extension of geometric data, such as<ul>
<li>Normal maps</li>
<li>Displacement maps</li>
<li>Transparency maps</li>
</ul>
</li>
<li>Accessing and <a href="#bsdf-interface">computing appearance attributes that depends on the BSDF model</a> used to render the object, such as<ul>
<li>Blinn-Phong BSDF (default BSDF in Radium Engine)</li>
<li>Microfacet - based BSDF (added by plugins such as GLTF-2 or PBRT)</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="vrtx-attr-interface"></a>
Vertex attrib interface</h3>
<p>In order to compute the appearance of an object, one need to rely on parameters defined directly on the geometry of the object. Such parameters (position, normal, tangent, ...) are passed to the shader systems as vertex attributes.</p>
<p>In order to keep the appearance computation agnostic on the way vertex attribs are named or accessed, we must propose an abstract interface. But, and this is particular to these attributes, one can access to the attributes himself, on the vertex, or to the attributes interpolated by the rasterizer, on the fragment. Accessing the Attribute directly on the vertex (i.e. on a vertex shader) does not necessitate an interface as each shader must define its attributes and as the ./mesh.md "Mesh API" allows to communicate between C++ and GLSL.</p>
<p>Note that the attributes accessed through the Vertex attrib interface <b>must</b> be defined in world space. Even if not necessarily efficient (some transformations might be computed twice), this will ensure more simple lighting computation. This might be changed in future version of Radium.</p>
<p>Each glsl component that needs to access to fragment-interpolated attributes must do that through this interface. The default declaration and implementation of this fragment interface is given in the file <code>Shaders/Materials/VertexAttribInterface.frag.glsl</code>. This interface might be included in any <b>fragment shader</b> that want to use it by <code>#include "VertexAttribInterface.frag.glsl"</code>.</p>
<p>It relies on some standard vertex attribute that have to be set by the vertex shader with respect to the following out binding : </p><div class="fragment"><div class="line"><span class="comment">// All attributes are given in world space</span></div><div class="line">layout (location = 0) out vec3 position;</div><div class="line">layout (location = 1) out vec3 normal;</div><div class="line">layout (location = 2) out vec3 texcoord;</div><div class="line">layout (location = 3) out vec3 vertexcolor;</div><div class="line">layout (location = 4) out vec3 tangent;</div></div><!-- fragment --><p> The default implementation of the fragment interface is robust to inactive attributes, i.e. attributes that are not set by the vertex shader.</p>
<p>If one wants to implement its own vertex attribute interface, in order, e.g., to take advantage of some application specific data layout, the following declaration of the glsl functions exported by the interface must be done. The implementation of the interface could then be developed in the appropriate glsl file. Note that not all the functions must be pre-declared and the programmer could restrict himself to the only functions he needs :</p>
<div class="fragment"><div class="line"><span class="comment">// Return the Vertex position, in world space, defined or interpolated from vertices</span></div><div class="line">vec4 getWorldSpacePosition();</div><div class="line"></div><div class="line"><span class="comment">// Return the geometric normal, in world space, defined or interpolated from vertices</span></div><div class="line">vec3 getWorldSpaceNormal();</div><div class="line"></div><div class="line"><span class="comment">//Return the geometric tangent, in world space, defined or interpolated from vertices</span></div><div class="line">vec3 getWorldSpaceTangent();</div><div class="line"></div><div class="line"><span class="comment">//Return the geometric bi-tangent, in world space, defined or interpolated from vertices</span></div><div class="line">vec3 getWorldSpaceBiTangent();</div><div class="line"></div><div class="line"><span class="comment">//Return the 2D parametric position of the vertex (the texture coords), defined or interpolated from vertices</span></div><div class="line">vec3 getPerVertexTexCoord();</div><div class="line"></div><div class="line"><span class="comment">// Return the base color, defined or interpolated from vertices</span></div><div class="line">vec4 getPerVertexBaseColor();</div><div class="line"></div><div class="line"><span class="comment">// return the specular color, defined or interpolated from vertices</span></div><div class="line">vec3 getPerVertexSpecularColor();</div></div><!-- fragment --><p>Note also that if a function is not needed by a shader, there is no need to implement its interface.</p>
<h3><a class="anchor" id="microgeometry-interface"></a>
Microgeometry interface</h3>
<p>Defining the micro-geometry procedurally or by using textures allows to de-correlates the geometric sampling from the appearance parameters sampling. The best example of procedural micro-geometry is normal mapping.</p>
<p>For a practical introduction to this kind of approach with opengl, the reader could refer to the <a href="https://learnopengl.com/">Learn opengl tutorial</a>.</p>
<p>For a more indepth presentation of these kind of techniques for realtime rendering, we encourage the reader to refer to <a href="https://www.realtimerendering.com/">Real-Time Rendering, Fourth Edition, by Tomas Akenine-Möller, Eric Haines, Naty Hoffman, Angelo Pesce, Michał Iwanicki and Sébastien Hillaire</a>.</p>
<p>The microgeometry could also define which fragment is transparent. So, in order to be able to compute or discard transparent fragments, one need to define a <code>toDiscard</code> function.</p>
<p>The interface (to be implemented in the file <code>name_of_the_BSDF.glsl</code>) is then</p>
<div class="fragment"><div class="line"><span class="comment">// Return the world-space normal computed according to the microgeometry definition`</span></div><div class="line"><span class="comment">// If no normal map is defined, return N</span></div><div class="line">vec3 getNormal(Material material, vec3 texCoord, vec3 N, vec3 T, vec3 B);</div><div class="line"><span class="comment">// return true if the fragment must be condidered as transparent (either fully or partially)</span></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> toDiscard(Material material, vec4 color);</div></div><!-- fragment --><h3><a class="anchor" id="bsdf-interface"></a>
BSDF interface</h3>
<p>Implementing or using the GLSL BSDF interface is based on the fact that the method <a class="el" href="classRa_1_1Engine_1_1Material.html#acb7b932175c1d8e93ece6ee39da4768b">Ra::Engine::Material::getMaterialName()</a> must return a string that contains the <code>name_of_the_BSDF</code> implemented in a file named <code>name_of_the_BSDF.glsl</code>. This file is preloaded at <a href="#registration-mtl-lib">material registration</a> into a <code>glNamedString</code> to allow inclusion by others.</p>
<p>In order to be composable by Radium applications and renderers, this glsl file must only contains the implementation of the BSDF interface, with no <code>void main(){...}</code>, the implementation of the micro-geometry interface and must only access to vertex attribs by using the vertex attribute interface or so on ...</p>
<p>This file must contain an inclusion guard : </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef METALLICROUGHNESS_GLSL</span></div><div class="line"><span class="preprocessor">#define METALLICROUGHNESS_GLSL</span></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">#endif</div></div><!-- fragment --><p>The BSDF interface consists in the following</p>
<div class="fragment"><div class="line"><span class="comment">// Concrete definition of the Material structure that contains the BSDF parameters</span></div><div class="line"><span class="keyword">struct </span>Material {</div><div class="line">    ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Returns the base color, or albedo, of the material, at the surface coordinates defined by texCoord.</span></div><div class="line"><span class="comment">// The returned color will eventually be used to infer if the fragment is transparent or not.</span></div><div class="line"><span class="comment">// The alpha channel could then vary from 0 (totally transparent) to 1 (totally opaque)</span></div><div class="line">vec4 getBaseColor(Material material, vec3 texCoord);</div><div class="line"></div><div class="line"><span class="comment">// Returns the so called &quot;Diffuse Color&quot; of the material, at the surface coordinates defined by texCoord.</span></div><div class="line"><span class="comment">// This could be the same that the base color or obtained by a more or less complex computation (Fresnel, ...)</span></div><div class="line"><span class="comment">// The alpha channel is the same than the one computed for getBaseColor().</span></div><div class="line"><span class="comment">// Note : might be deprecated in a near future (see getSeparateBSDFComponent)</span></div><div class="line">vec4 getDiffuseColor(Material material, vec3 texCoord);</div><div class="line"></div><div class="line"><span class="comment">// Returns the so called &quot;Specular Color&quot; of the material, at the surface coordinates defined by texCoord.</span></div><div class="line"><span class="comment">// This could be the same that the base color (without the alpha channel) or obtained by</span></div><div class="line"><span class="comment">// a more or less complex computation</span></div><div class="line"><span class="comment">// Note : might be deprecated in a near future (see getSeparateBSDFComponent)</span></div><div class="line">vec3 getSpecularColor(Material material, vec3 texCoord);</div><div class="line"></div><div class="line"><span class="comment">// Return the reflectance value for the material, at surface coordinates defined by texCoord,</span></div><div class="line"><span class="comment">// for the incoming and outgoing directions `wi` and `wo`. </span></div><div class="line"><span class="comment">// the reflectance value is defined as bsdf * cos(Theta_i).</span></div><div class="line"><span class="comment">// IMPORTANT : for efficiency reasons, these directions MUST be in local frame.</span></div><div class="line"><span class="comment">// The local Frame is the Frame wher the Geometric normal is the Z axis,</span></div><div class="line"><span class="comment">// and the tangent defined the X axis.</span></div><div class="line">vec3 evaluateBSDF(Material material, vec3 texCoord, vec3 wi, vec3 wo);</div><div class="line"></div><div class="line"><span class="comment">// Extract separated components of the bsdf value for the material according to the Light/View/Normal configuration. </span></div><div class="line"><span class="comment">// This function must return 0 if the bsdf is not defined for the given configuration (e.g. back-face lighting) and 1 </span></div><div class="line"><span class="comment">// if the results are usable.</span></div><div class="line"><span class="comment">// Separated components are the diffuse part of the BSDF and the specular part of the BSDF.</span></div><div class="line"><span class="comment">// NOTE : these separated components must not include the cos(Theta_i).</span></div><div class="line"><span class="comment">// NOTE : For non separable bsdf model (e.g. bsdf encoded on shperical Harmonics), it is recomended to set the diffuse </span></div><div class="line"><span class="comment">// part to 0 and to evaluate the bsdf in the specular part.</span></div><div class="line"><span class="keywordtype">int</span> getSeparateBSDFComponent(Material material, vec3 texCoord, vec3 Light, vec3 View, vec3 <a class="code" href="namespaceRa_1_1Engine_1_1DrawPrimitives.html#a149cfbf089266ed652ddcd8a7bc6c7c5">Normal</a>, out vec3 diffuse, out vec3 specular);</div><div class="line"></div><div class="line"><span class="comment">// Return the GGX equivalent &quot;roughness&quot; of the BSDF as defined in the GGX microfacet bsdf model.</span></div><div class="line"><span class="comment">// Roughness might range from 0.04 to 1 for specular to diffuse materials.</span></div><div class="line"><span class="comment">// This roughness might be used, e.g. to filter environment map when computing environment lighting.</span></div><div class="line"><span class="keywordtype">float</span> getGGXRoughness(Material material, vec3 texCoord);</div></div><!-- fragment --><h3><a class="anchor" id="emissivity-interface"></a>
Emissivity interface</h3>
<p>Some materials are not only reflective, hence implementing the BSDF interface, but also can be emissive. To allow a renderer to access the emissivity of a material the following GLSL function must defined in the same GLSL file than the BSDF and microgeometry interface : </p><div class="fragment"><div class="line">// Return the emissivity of the material</div><div class="line">vec3 getEmissiveColor(GLTFCommon material, vec3 textCoord);</div></div><!-- fragment --><h2><a class="anchor" id="registration-mtl-lib"></a>
Material registration into the Engine</h2>
<p>When implementing the <a href="#glsl-mtl-lib">GLSL interface</a> of a Material, the user can rely on several glsl components defined by the Engine. Glsl components are helper functions and data structure that could be used to develop specific shaders.</p>
<p>To make this common component available to users, and also each user defined component that want to be available to others, the Radium Engine defines a material component registration system that allows to populate and extend the <em>Radium Material Library</em>.</p>
<p>The registration and glsl component access system is made of 3 parts</p><ol type="1">
<li>Registration of OpenGL/GLSL named string : defining a re-usable GLSL component.</li>
<li>Registration of OpenGL/GLSL Program configuration : defining how to link shaders into a program for a specific rendering step.</li>
<li>Render Technique factory : defining which Program configurations must be used for each renderer-specific task.</li>
</ol>
<p>a fourth part, optional, could be defined to convert a <a class="el" href="namespaceRa_1_1Core_1_1Asset.html">Ra::Core::Asset</a>:MaterialData (file representation of a material) to a <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a>.</p>
<h3>Registration of OpenGL/GLSL named string</h3>
<p>Relying on already developed GLSL component require that this component could be included in the client code. In GLSL, this is done using the preprocessor directive <code>#include &lt;/ComponentPath/ComponentName.glsl&gt;</code>. As specified by the ARB_shading_language_include specification, included files must be preloaded in a GlNamedString object. The Ra::Engine::ShaderManager provide a way to populate the GLNamedString ecosystem.</p>
<p>To register a GLSL component, from a file named <code>SharedComponent.glsl</code>, so that it could be included in others GLSL files by <code>#include &lt;/SharedComponent.glsl&gt;</code>, one just need to do the following</p>
<div class="fragment"><div class="line"><span class="comment">// adding the material glsl implementation file</span></div><div class="line">ShaderProgramManager::getInstance()-&gt;addNamedString(</div><div class="line">    <span class="stringliteral">&quot;/SharedComponent.glsl&quot;</span>, <span class="stringliteral">&quot;/absolute/path/to/file/SharedComponent.glsl&quot;</span> );</div></div><!-- fragment --><h3>Registration of OpenGL/GLSL Program configuration</h3>
<p>The use of GLSL component to render object requires the building of a render-task specific OpenGL Program that link together the GLSL component and shaders addressing stages of the OpenGL Pipeline. According to the OpenGL specification, A vertex shader and a fragment shader stage are mandatory whereas tesselation end geometry shader are optional and depends only of the way one want to configure its pipeline for rendering.</p>
<p>To describe the OpenGL program configuration, and make it reusable, the configuration must be registered in the <a class="el" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html">Ra::Engine::ShaderConfigurationFactory</a>. To do that, for each reusable configuration, one just need to do the following </p><div class="fragment"><div class="line"><span class="comment">// build the configuration</span></div><div class="line"><a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> myConfig(</div><div class="line">    <span class="stringliteral">&quot;ConfigName&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;absolute/path/to/vertexshader.vert.glsl&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;absolute/path/to/fragmentshader.vert.glsl&quot;</span>, );</div><div class="line"><span class="comment">// add optional components of the configuration (#define, geometry shaders, ...</span></div><div class="line">...</div><div class="line"><span class="comment">// Register the configuration to the factory</span></div><div class="line">Ra::Engine::ShaderConfigurationFactory::addConfiguration( myConfig );</div></div><!-- fragment --><p>once registered, a shader configuration could be fetched from the factory by its name : </p><div class="fragment"><div class="line"><span class="keyword">auto</span> theConfig =</div><div class="line">                <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#ad6fe3c60f8f2b9f9f5d8220ffe4d5ba6">Ra::Engine::ShaderConfigurationFactory::getConfiguration</a>( <span class="stringliteral">&quot;ConfigName&quot;</span> );</div></div><!-- fragment --><h3>Registering a RenderTechnique</h3>
<p>A <a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> describes which <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> a renderer will use for each of its rendering passes. Such a render technique could encompass a <a class="el" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> but its meaning is larger than just computing the BSDF. In order to make a GLSL component that compute the appearance of a 3D object usable by a the default Radium renderer, one must define which shader configuration to use for each pass of the renderer. A Render technique will be used to configure the rendering of a geometry and the association between the geometry and the render technique is made in a <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a>. Making a GLSL component available for the <a class="el" href="classRa_1_1Engine_1_1ForwardRenderer.html">Ra::Engine::ForwardRenderer</a> default renderer in Radium, on must define which <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> to use for the passes Ra::Engine::DefaultRenderingPasses::LIGHTING_OPAQUE, Ra::Engine::DefaultRenderingPasses::Z_PREPASS and, if the appearance might be transparent, Ra::Engine::DefaultRenderingPasses::LIGHTING_TRANSPARENT.</p>
<p>To do that, the Default render technique, the one that wil be used by <a class="el" href="classRa_1_1Engine_1_1ForwardRenderer.html">Ra::Engine::ForwardRenderer</a> must be registered into the <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html">Ra::Engine::EngineRenderTechniques</a> factory. This is done according to the following</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#affc37bf84d5ff81342b5c09587eedc34">Ra::Engine::EngineRenderTechniques::registerDefaultTechnique</a>(</div><div class="line">        <span class="comment">// This name will be used to query the RenderTechnique when rendering</span></div><div class="line">        <span class="stringliteral">&quot;NameOfTheTechnique&quot;</span>, </div><div class="line">        <span class="comment">// This lambda will be executed to configure the rendering technique for a RenderObject</span></div><div class="line">        []( <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>&amp; rt, <span class="keywordtype">bool</span> isTransparent ) {</div><div class="line">            <span class="comment">// Configure the technique to render this object at the mandatory pass</span></div><div class="line">            <span class="keyword">auto</span> lightpass =</div><div class="line">                <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#ad6fe3c60f8f2b9f9f5d8220ffe4d5ba6">Ra::Engine::ShaderConfigurationFactory::getConfiguration</a>( <span class="stringliteral">&quot;MyTechniqueOpaque&quot;</span> );</div><div class="line">            rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a22298207c6e70a98b829d6c5ead1a8e4">setConfiguration</a>( lightpass, <a class="code" href="namespaceRa_1_1Engine.html#af0d75e4930eb1c298806919c11d76b6aa3ff0ae60cd426d7a2f272a7c652837d7">DefaultRenderingPasses::LIGHTING_OPAQUE</a> );</div><div class="line"></div><div class="line">            <span class="comment">// Z prepass (Recommended) : </span></div><div class="line">            <span class="keyword">auto</span> zprepass =</div><div class="line">                <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#ad6fe3c60f8f2b9f9f5d8220ffe4d5ba6">Ra::Engine::ShaderConfigurationFactory::getConfiguration</a>( <span class="stringliteral">&quot;MyTechniqueZprepass&quot;</span> );</div><div class="line">            rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a22298207c6e70a98b829d6c5ead1a8e4">setConfiguration</a>( zprepass, <a class="code" href="namespaceRa_1_1Engine.html#af0d75e4930eb1c298806919c11d76b6aa1e9cbadaa169fba4449aa3547fa8d05e">DefaultRenderingPasses::Z_PREPASS</a> );</div><div class="line">            <span class="comment">// Transparent pass (0ptional) : If Transparent ... add LitOIT</span></div><div class="line">            <span class="keywordflow">if</span> ( isTransparent )</div><div class="line">            {</div><div class="line">                <span class="keyword">auto</span> transparentpass =</div><div class="line">                    <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#ad6fe3c60f8f2b9f9f5d8220ffe4d5ba6">Ra::Engine::ShaderConfigurationFactory::getConfiguration</a>( <span class="stringliteral">&quot;MyTechiqueTransparent&quot;</span> );</div><div class="line">                rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a22298207c6e70a98b829d6c5ead1a8e4">setConfiguration</a>( transparentpass,</div><div class="line">                                     <a class="code" href="namespaceRa_1_1Engine.html#af0d75e4930eb1c298806919c11d76b6aac406874ced20cbe0595d8eadd0a194be">DefaultRenderingPasses::LIGHTING_TRANSPARENT</a> );</div><div class="line">            }</div><div class="line">        } );</div></div><!-- fragment --><p>once registered, the render technique could then be associated with any render object using the following principle : </p><div class="fragment"><div class="line"><span class="comment">// Construct and initialize a Ra::Engine::RenderTechnique object</span></div><div class="line"><a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> rt;</div><div class="line"><span class="comment">// Associate a Ra::engine::Material with the render technique if needed</span></div><div class="line"><span class="keywordtype">bool</span> isMaterialTransparent = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">if</span> ( haveMaterial ) {</div><div class="line">    std::shared_ptr&lt;Ra::Engine::Material&gt; radiumMaterial( <span class="keyword">new</span> MyMaterial(...) );</div><div class="line">    isMaterialTransparent = radiumMaterial-&gt;isTransparent();</div><div class="line">    rt.setMaterial( radiumMaterial );</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    rt.setMaterial( <span class="keyword">nullptr</span> );</div><div class="line">}</div><div class="line"><span class="comment">// configure the render technique for rendering this material with the default renderer</span></div><div class="line"><span class="keyword">auto</span> builder = <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a5e831d5088144082e9bd3828323aa57a">Ra::Engine::EngineRenderTechniques::getDefaultTechnique</a>( <span class="stringliteral">&quot;NameOfTheTechnique&quot;</span> );</div><div class="line">builder.second( rt, isMaterialTransparent );</div></div><!-- fragment --><h2><a class="anchor" id="non-bsdf-rendering"></a>
Rendering without using Materials</h2>
<p>The <em>Radium Material Library</em> and related components are mainly designed to manage Materials as a representation of a <em>Bidirectional Scattering Distribution function (BSDF)</em>.</p>
<p>When rendering, it is sometime useful to compute the final color of an object that do not rely on a bsdf but just on a specific color for each geometry fragment.</p>
<p>To define a custom fragment's color computation shader and use it with application provided parameters, the following steps are required :</p>
<ol type="1">
<li>Develop specific vertex and fragment shaders to compute the fragment color</li>
<li>Build a <a class="el" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> that uses these shaders</li>
<li>Build a render technique that use this configuration</li>
<li>If the shaders have uniform parameters, implement a specific <a class="el" href="classRa_1_1Engine_1_1ShaderParameterProvider.html">Ra::Engine::ShaderParameterProvider</a> and associate an instance of the parameter provider to the render technique.</li>
<li>Associate the render technique with a geometry in a <a class="el" href="classRa_1_1Engine_1_1RenderObject.html">Ra::Engine::RenderObject</a></li>
</ol>
<p>Here is an example snippet. </p><div class="fragment"><div class="line"><span class="comment">// 1. Implement a parameter provider to provide the uniforms for the shader</span></div><div class="line"><span class="keyword">class </span>MyParameterProvider : <span class="keyword">public</span> <a class="code" href="namespaceRa.html">Ra</a>:Engine::ShaderParameterProvider {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MyParameterProvider() {}</div><div class="line">  ~MyParameterProvider() {}</div><div class="line">  <span class="keywordtype">void</span> updateGL()<span class="keyword"> override </span>{</div><div class="line">    <span class="comment">// Method called before drawing each frame in Renderer::updateRenderObjectsInternal.</span></div><div class="line">    <span class="comment">// The name of the parameter corresponds to the shader&#39;s uniform name.</span></div><div class="line">    m_renderParameters.addParameter( <span class="stringliteral">&quot;aColorUniform&quot;</span>, m_colorParameter );</div><div class="line">    m_renderParameters.addParameter( <span class="stringliteral">&quot;aScalarUniform&quot;</span>, m_scalarParameter );</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setOrComputeTheParameterValues() {</div><div class="line">    <span class="comment">// client side computation of the parameters, e.g.</span></div><div class="line">    m_colorParameter = Ra::Core::Color::Red();</div><div class="line">    m_scalarParameter = .5_ra;</div><div class="line">  }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespaceRa_1_1Core_1_1Utils.html#a847b1262d9272f37005c731601da5580">Ra::Core::Color</a> m_colorParameter;</div><div class="line">  <a class="code" href="CoreMacros_8hpp.html#a4be45d931ceeeea4be9f14978f30e498">Scalar</a> m_scalarParameter;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 2. Implement a specific vertex and fragment shaders to compute the fragment color based on uniform values</span></div><div class="line"><span class="comment">// Vertex shader source code</span></div><div class="line"><span class="keyword">const</span> std::string vertexShaderSource{</div><div class="line">    <span class="stringliteral">&quot;#include \&quot;TransformStructs.glsl\&quot;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;layout (location = 0) in vec3 in_position;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;uniform Transform transform;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main(void)\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    mat4 mvp = transform.proj * transform.view;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    gl_Position = mvp*vec4(in_position.xyz, 1.0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>};</div><div class="line"><span class="comment">// Fragment shader source code</span></div><div class="line"><span class="keyword">const</span> std::string fragmentShaderSource{</div><div class="line">    <span class="stringliteral">&quot;layout (location = 0) out vec4 out_color;\n&quot;</span></div><div class="line">     <span class="stringliteral">&quot;uniform vec4 aColorUniform;\n&quot;</span></div><div class="line">     <span class="stringliteral">&quot;uniform float aScalarUniform;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main(void)\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    out_color =  aColorUniform*aScalarUniform;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>};</div><div class="line"></div><div class="line"><span class="comment">// 3. Setup a Ra::Engine::ShaderConfiguration that uses these shaders</span></div><div class="line"><a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> myConfig{<span class="stringliteral">&quot;MyColorComputation&quot;</span>};</div><div class="line">config.<a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html#a01b1f142d289033a7ef850625426f12e">addShaderSource</a>( <a class="code" href="namespaceRa_1_1Engine.html#a01c64ec07c4055ad0185376972e97352a70c9fa90da8d232523bf8e1f5ccbeb7c">Ra::Engine::ShaderType::ShaderType_VERTEX</a>, vertexShaderSource );</div><div class="line">config.addShaderSource( <a class="code" href="namespaceRa_1_1Engine.html#a01c64ec07c4055ad0185376972e97352a3350d3906d171c77c1882934c72ae2b0">Ra::Engine::ShaderType::ShaderType_FRAGMENT</a>, fragmentShaderSource );</div><div class="line"><a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#a36842535508a390108fb1205210a5c49">Ra::Engine::ShaderConfigurationFactory::addConfiguration</a>( myConfig );</div><div class="line"></div><div class="line"><span class="comment">// 4. Build a render technique that use this configuration</span></div><div class="line"><a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> renderTechnique;</div><div class="line">renderTechnique.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a22298207c6e70a98b829d6c5ead1a8e4">setConfiguration</a>( myConfig, <a class="code" href="namespaceRa_1_1Engine.html#af0d75e4930eb1c298806919c11d76b6aa3ff0ae60cd426d7a2f272a7c652837d7">DefaultRenderingPasses::LIGHTING_OPAQUE</a> );</div><div class="line"></div><div class="line"><span class="comment">// 5. Create and associate the parameter provider with the RenderTechnique</span></div><div class="line"><span class="keyword">auto</span> parameterProvider = std::make_shared&lt;MyParameterProvider&gt;();</div><div class="line">parameterProvider-&gt;setOrComputeTheParameterValues();</div><div class="line">renderTechnique.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a92778b063ae626dfac4a18d0f69fec5a">setParametersProvider</a>(parameterProvider);</div><div class="line"></div><div class="line"><span class="comment">// 6. Associate the render technique with a geometry in a Ra::Engine::RenderObject</span></div><div class="line">std::shared_ptr&lt;Ra::Engine::Mesh&gt; mesh( <span class="keyword">new</span> <a class="code" href="classRa_1_1Engine_1_1Mesh.html">Ra::Engine::Mesh</a>( <span class="stringliteral">&quot;my mesh&quot;</span> ) );</div><div class="line">mesh-&gt;loadGeometry( <a class="code" href="namespaceRa_1_1Core_1_1Geometry.html#a97444ae32c928b107e10c0a30dd4fb96">Ra::Core::Geometry::makeSharpBox</a>( {0.1f, 0.1f, 0.1f} ) );</div><div class="line"><span class="keyword">auto</span> renderObject = <a class="code" href="classRa_1_1Engine_1_1RenderObject.html#af89f107cde1254df714a5131b050e477">Ra::Engine::RenderObject::createRenderObject</a>(</div><div class="line">    <span class="stringliteral">&quot;myRenderObject&quot;</span>, radiumComponent,</div><div class="line">    <a class="code" href="namespaceRa_1_1Engine.html#ad6bd78a7bc92ffea3c8514ef97b43ea7ad9c6333623e6357515fcbf17be806273">Ra::Engine::RenderObjectType::Geometry</a>, mesh, renderTechnique );</div><div class="line">addRenderObject( renderObject );</div><div class="line"><span class="comment">// where radiumComponent is a component of the scene.</span></div></div><!-- fragment --><p>Then the draw call of <code>renderObject</code> uses the <code>myConfig</code> as shader configuration. Before rendering, the method <code>updateGL</code> on the <code>parameterProvider</code> instance is called so that the shader's uniforms values are updated according the one stored in <code>parameterProvider</code>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="develmanual.html">Developer manual</a></li><li class="navelem"><a class="el" href="api.html">API</a></li><li class="navelem"><a class="el" href="engine.html">Engine</a></li>
    <li class="footer">Generated on Tue Nov 17 2020 16:20:33 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
